
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _common_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class CreateAsyncGroupsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.create_async_groups"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, use_mma_sync, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["use_mma_sync"] = (use_mma_sync if (
    issubclass(type(use_mma_sync), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(use_mma_sync, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def use_mma_sync(self):
    return _ods_ir.BoolAttr(self.operation.attributes["use_mma_sync"])

  @use_mma_sync.setter
  def use_mma_sync(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["use_mma_sync"] = value

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MapNestedForallToGpuThreadsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.map_nested_forall_to_gpu_threads"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, workgroup_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if workgroup_size is not None: attributes["workgroup_size"] = (workgroup_size if (
        issubclass(type(workgroup_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(workgroup_size, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PipelineSharedMemoryCopiesOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.pipeline_shared_memory_copies"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, for_op, depth, *, peel_epilogue=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(for_op))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["depth"] = (depth if (
    issubclass(type(depth), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(depth, context=_ods_context))
    if bool(peel_epilogue): attributes["peel_epilogue"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def for_op(self):
    return self.operation.operands[0]

  @builtins.property
  def depth(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["depth"])

  @depth.setter
  def depth(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["depth"] = value

  @builtins.property
  def peel_epilogue(self):
    return "peel_epilogue" in self.operation.attributes

  @peel_epilogue.setter
  def peel_epilogue(self, value):
    if bool(value):
      self.operation.attributes["peel_epilogue"] = _ods_ir.UnitAttr.get()
    elif "peel_epilogue" in self.operation.attributes:
      del self.operation.attributes["peel_epilogue"]

  @peel_epilogue.deleter
  def peel_epilogue(self):
    del self.operation.attributes["peel_epilogue"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PromoteOperandsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.promote_operands"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, indices=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if indices is not None: attributes["indices"] = (indices if (
        issubclass(type(indices), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(indices, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VectorToMMAConversionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.vector.vector_to_mma_conversion"

  _ODS_REGIONS = (0, True)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def use_mma_sync(self):
    return "use_mma_sync" in self.operation.attributes

  @use_mma_sync.setter
  def use_mma_sync(self, value):
    if bool(value):
      self.operation.attributes["use_mma_sync"] = _ods_ir.UnitAttr.get()
    elif "use_mma_sync" in self.operation.attributes:
      del self.operation.attributes["use_mma_sync"]

  @use_mma_sync.deleter
  def use_mma_sync(self):
    del self.operation.attributes["use_mma_sync"]

  @builtins.property
  def use_wmma(self):
    return "use_wmma" in self.operation.attributes

  @use_wmma.setter
  def use_wmma(self, value):
    if bool(value):
      self.operation.attributes["use_wmma"] = _ods_ir.UnitAttr.get()
    elif "use_wmma" in self.operation.attributes:
      del self.operation.attributes["use_wmma"]

  @use_wmma.deleter
  def use_wmma(self):
    del self.operation.attributes["use_wmma"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VectorToWarpExecuteOnLane0Op(_ods_ir.OpView):
  OPERATION_NAME = "transform.vector.to_warp_execute_on_lane_0"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, warp_size=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if warp_size is not None: attributes["warp_size"] = (warp_size if (
        issubclass(type(warp_size), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(warp_size, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def warp_size(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["warp_size"])

  @warp_size.setter
  def warp_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["warp_size"] = value

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VectorWarpDistributionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.vector.warp_distribute"

  _ODS_REGIONS = (0, True)

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]
